<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/image.png"><title>JS 基础知识点及常考面试题（一） | 山楂的日常</title><meta name="description" content="书以明志  锤炼技艺  快乐生活">
    <link rel="modulepreload" href="/assets/app.d9a40c70.js"><link rel="modulepreload" href="/assets/index.html.9fdfbfba.js"><link rel="modulepreload" href="/assets/index.html.5c8731c1.js"><link rel="prefetch" href="/assets/index.html.51df35be.js"><link rel="prefetch" href="/assets/home.html.b6aa89aa.js"><link rel="prefetch" href="/assets/index.html.17783b17.js"><link rel="prefetch" href="/assets/JavaScript.html.bcb8e6eb.js"><link rel="prefetch" href="/assets/blog.html.271dd993.js"><link rel="prefetch" href="/assets/a.html.b8b52ce1.js"><link rel="prefetch" href="/assets/b.html.536c1807.js"><link rel="prefetch" href="/assets/2022.html.90bc248d.js"><link rel="prefetch" href="/assets/index.html.39b4b3a7.js"><link rel="prefetch" href="/assets/404.html.7d858b3d.js"><link rel="prefetch" href="/assets/index.html.ea262036.js"><link rel="prefetch" href="/assets/home.html.32356c8a.js"><link rel="prefetch" href="/assets/index.html.b51d3b3e.js"><link rel="prefetch" href="/assets/JavaScript.html.24fc6b58.js"><link rel="prefetch" href="/assets/blog.html.5fd5cbd8.js"><link rel="prefetch" href="/assets/a.html.364eade0.js"><link rel="prefetch" href="/assets/b.html.0c53fbc7.js"><link rel="prefetch" href="/assets/2022.html.af3a1600.js"><link rel="prefetch" href="/assets/index.html.a09d1fc4.js"><link rel="prefetch" href="/assets/404.html.036734e7.js"><link rel="prefetch" href="/assets/404.f72f7edb.js"><link rel="prefetch" href="/assets/Layout.fa69f64c.js">
    <link rel="stylesheet" href="/assets/style.96ee71b5.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">山楂的日常</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/home" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/book" class="" aria-label="读书日记"><!--[--><!--]--> 读书日记 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="技术总结"><span class="title">技术总结</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="技术总结"><span class="title">技术总结</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technique/JavaScript" class="" aria-label="JS总结"><!--[--><!--]--> JS总结 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technique/blog" class="" aria-label="博客部署"><!--[--><!--]--> 博客部署 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="前端相关技术文档收集"><span class="title">前端相关技术文档收集</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="前端相关技术文档收集"><span class="title">前端相关技术文档收集</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a aria-current="page" href="/pages/interview" class="router-link-active router-link-exact-active router-link-active" aria-label="前端面试之道"><!--[--><!--]--> 前端面试之道 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="生活"><span class="title">生活</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="生活"><span class="title">生活</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/pages/summary" class="" aria-label="年终总结"><!--[--><!--]--> 年终总结 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a href="/about" class="" aria-label="关于我"><!--[--><!--]--> 关于我 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/home" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/book" class="" aria-label="读书日记"><!--[--><!--]--> 读书日记 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="技术总结"><span class="title">技术总结</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="技术总结"><span class="title">技术总结</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/technique/JavaScript" class="" aria-label="JS总结"><!--[--><!--]--> JS总结 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/technique/blog" class="" aria-label="博客部署"><!--[--><!--]--> 博客部署 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="前端相关技术文档收集"><span class="title">前端相关技术文档收集</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="前端相关技术文档收集"><span class="title">前端相关技术文档收集</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a aria-current="page" href="/pages/interview" class="router-link-active router-link-exact-active router-link-active" aria-label="前端面试之道"><!--[--><!--]--> 前端面试之道 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="生活"><span class="title">生活</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="生活"><span class="title">生活</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/pages/summary" class="" aria-label="年终总结"><!--[--><!--]--> 年终总结 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a href="/about" class="" aria-label="关于我"><!--[--><!--]--> 关于我 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading active">前端面试之道 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/pages/interview/" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="JS 基础知识点及常考面试题（一）"><!--[--><!--]--> JS 基础知识点及常考面试题（一） <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/pages/interview/#原始-primitive-类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="原始（Primitive）类型"><!--[--><!--]--> 原始（Primitive）类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/pages/interview/#对象-object-类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="对象（Object）类型"><!--[--><!--]--> 对象（Object）类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/pages/interview/#typeof-vs-instanceof" class="router-link-active router-link-exact-active sidebar-item" aria-label="#typeof vs instanceof"><!--[--><!--]--> #typeof vs instanceof <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/pages/interview/#类型转换" class="router-link-active router-link-exact-active sidebar-item" aria-label="#类型转换"><!--[--><!--]--> #类型转换 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/pages/interview/#转boolean" class="router-link-active router-link-exact-active sidebar-item" aria-label="#转Boolean"><!--[--><!--]--> #转Boolean <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/pages/interview/#对象转原始类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="#对象转原始类型"><!--[--><!--]--> #对象转原始类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/pages/interview/#四则运算符" class="router-link-active router-link-exact-active sidebar-item" aria-label="#四则运算符"><!--[--><!--]--> #四则运算符 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/pages/interview/#比较运算符" class="router-link-active router-link-exact-active sidebar-item" aria-label="#比较运算符"><!--[--><!--]--> #比较运算符 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/pages/interview/#this" class="router-link-active router-link-exact-active sidebar-item" aria-label="#this"><!--[--><!--]--> #this <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/pages/interview/#小结" class="router-link-active router-link-exact-active sidebar-item" aria-label="小结"><!--[--><!--]--> 小结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/pages/interview/a.html" class="sidebar-item" aria-label="JS 基础知识点及常考面试题（二）"><!--[--><!--]--> JS 基础知识点及常考面试题（二） <!--[--><!--]--></a><!----></li><li><a href="/pages/interview/b.html" class="sidebar-item" aria-label="ES6 知识点及常考面试题"><!--[--><!--]--> ES6 知识点及常考面试题 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="js-基础知识点及常考面试题-一" tabindex="-1"><a class="header-anchor" href="#js-基础知识点及常考面试题-一" aria-hidden="true">#</a> JS 基础知识点及常考面试题（一）</h1><p>JS 对于每位前端开发都是必备技能，在小册中我们也会有多个章节去讲述这部分的知识。首先我们先来熟悉下 JS 的一些常考和容易混乱的基础知识点。</p><h2 id="原始-primitive-类型" tabindex="-1"><a class="header-anchor" href="#原始-primitive-类型" aria-hidden="true">#</a> 原始（Primitive）类型</h2><blockquote><p>涉及面试题：原始类型有哪几种？null 是对象嘛？</p></blockquote><p>在 JS 中，存在着 6 种原始值，分别是：</p><ul><li><code>boolean</code></li><li><code>null</code></li><li><code>undefined</code></li><li><code>number</code></li><li><code>string</code></li><li><code>symbol</code></li></ul><p>首先原始类型存储的都是值，是没有函数可以调用的，比如 <code>undefined.toString()</code></p><p><a href="https://user-gold-cdn.xitu.io/2018/11/14/16711c4f991c73ac?w=526&amp;h=53&amp;f=png&amp;s=10255" target="_blank" rel="noopener noreferrer">https://user-gold-cdn.xitu.io/2018/11/14/16711c4f991c73ac?w=526&amp;h=53&amp;f=png&amp;s=10255<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>此时你肯定会有疑问，这不对呀，明明 <code>&#39;1&#39;.toString()</code> 是可以使用的。其实在这种情况下，<code>&#39;1&#39;</code> 已经不是原始类型了，而是被强制转换成了 <code>String</code> 类型也就是对象类型，所以可以调用 <code>toString</code> 函数。</p><p>除了会在必要的情况下强转类型以外，原始类型还有一些坑。</p><p>其中 JS 的 <code>number</code> 类型是浮点类型的，在使用中会遇到某些 Bug，比如 <code>0.1 + 0.2 !== 0.3</code>，但是这一块的内容会在进阶部分讲到。<code>string</code> 类型是不可变的，无论你在 <code>string</code> 类型上调用何种方法，都不会对值有改变。</p><p>另外对于 <code>null</code> 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 <code>typeof null</code> 会输出 <code>object</code>，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，<code>000</code> 开头代表是对象，然而 <code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code> 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</p><h2 id="对象-object-类型" tabindex="-1"><a class="header-anchor" href="#对象-object-类型" aria-hidden="true">#</a> 对象（Object）类型</h2><blockquote><p>涉及面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？</p></blockquote><p>在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const a = []

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于常量 <code>a</code> 来说，假设内存地址（指针）为 <code>#001</code>，那么在地址 <code>#001</code> 的位置存放了值 <code>[]</code>，常量 <code>a</code> 存放了地址（指针） <code>#001</code>，再看以下代码</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const a = []
const b = a
b.push(1)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 <code>b</code> 存放的地址（指针）也是 <code>#001</code>，当我们进行数据修改的时候，就会修改存放在地址（指针） <code>#001</code> 上的值，也就导致了两个变量的值都发生了改变。</p><p>接下来我们来看函数参数是对象的情况</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function test(person) {
  person.age = 26
  person = {
    name: &#39;yyy&#39;,
    age: 30
  }

  return person
}
const p1 = {
  name: &#39;yck&#39;,
  age: 25
}
const p2 = test(p1)
console.log(p1) // -&gt; ?
console.log(p2) // -&gt; ?

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于以上代码，你是否能正确的写出结果呢？接下来让我为你解析一番：</p><ul><li>首先，函数传参是传递对象指针的副本</li><li>到函数内部修改参数的属性这步，我相信大家都知道，当前 <code>p1</code> 的值也被修改了</li><li>但是当我们重新为 <code>person</code> 分配了一个对象时就出现了分歧，请看下图</li></ul><p><a href="https://user-gold-cdn.xitu.io/2018/11/14/16712ce155afef8c?w=658&amp;h=414&amp;f=png&amp;s=37772" target="_blank" rel="noopener noreferrer">https://user-gold-cdn.xitu.io/2018/11/14/16712ce155afef8c?w=658&amp;h=414&amp;f=png&amp;s=37772<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>所以最后 <code>person</code> 拥有了一个新的地址（指针），也就和 <code>p1</code> 没有任何关系了，导致了最终两个变量的值是不相同的。</p><h2 id="typeof-vs-instanceof" tabindex="-1"><a class="header-anchor" href="#typeof-vs-instanceof" aria-hidden="true">#</a> <strong><a href="https://doc.vercel.app/webyck/article/5bdc715f6fb9a049c15ea4e0.html#typeof-vs-instanceof" target="_blank" rel="noopener noreferrer">#<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>typeof vs instanceof</strong></h2><blockquote><p>涉及面试题：typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？</p></blockquote><p><code>typeof</code> 对于原始类型来说，除了 <code>null</code> 都可以显示正确的类型</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>typeof 1 // &#39;number&#39;
typeof &#39;1&#39; // &#39;string&#39;
typeof undefined // &#39;undefined&#39;
typeof true // &#39;boolean&#39;
typeof Symbol() // &#39;symbol&#39;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>typeof</code> 对于对象来说，除了函数都会显示 <code>object</code>，所以说 <code>typeof</code> 并不能准确判断变量到底是什么类型</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>typeof [] // &#39;object&#39;
typeof {} // &#39;object&#39;
typeof console.log // &#39;function&#39;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们想判断一个对象的正确类型，这时候可以考虑使用 <code>instanceof</code>，因为内部机制是通过原型链来判断的，在后面的章节中我们也会自己去实现一个 <code>instanceof</code>。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true

var str = &#39;hello world&#39;
str instanceof String // false

var str1 = new String(&#39;hello world&#39;)
str1 instanceof String // true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于原始类型来说，你想直接通过 <code>instanceof</code> 来判断类型是不行的，当然我们还是有办法让 <code>instanceof</code> 判断原始类型的</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === &#39;string&#39;
  }
}
console.log(&#39;hello world&#39; instanceof PrimitiveString) // true

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可能不知道 <code>Symbol.hasInstance</code> 是什么东西，其实就是一个能让我们自定义 <code>instanceof</code> 行为的东西，以上代码等同于 <code>typeof &#39;hello world&#39; === &#39;string&#39;</code>，所以结果自然是 <code>true</code> 了。这其实也侧面反映了一个问题， <code>instanceof</code> 也不是百分之百可信的。</p><h2 id="类型转换" tabindex="-1"><a class="header-anchor" href="#类型转换" aria-hidden="true">#</a> <strong><a href="https://doc.vercel.app/webyck/article/5bdc715f6fb9a049c15ea4e0.html#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener noreferrer">#<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>类型转换</strong></h2><blockquote><p>涉及面试题：该知识点常在笔试题中见到，熟悉了转换规则就不惧怕此类题目了。</p></blockquote><p>首先我们要知道，在 JS 中类型转换只有三种情况，分别是：</p><ul><li>转换为布尔值</li><li>转换为数字</li><li>转换为字符串</li></ul><p>我们先来看一个类型转换表格，然后再进入正题</p><blockquote><p>注意图中有一个错误，Boolean 转字符串这行结果我指的是 true 转字符串的例子，不是说 Boolean、函数、Symblo 转字符串都是 <code>true</code></p></blockquote><p><a href="https://user-gold-cdn.xitu.io/2018/11/15/16716dec14421e47?w=910&amp;h=648&amp;f=png&amp;s=110463" target="_blank" rel="noopener noreferrer">https://user-gold-cdn.xitu.io/2018/11/15/16716dec14421e47?w=910&amp;h=648&amp;f=png&amp;s=110463<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h3 id="转boolean" tabindex="-1"><a class="header-anchor" href="#转boolean" aria-hidden="true">#</a> <strong><a href="https://doc.vercel.app/webyck/article/5bdc715f6fb9a049c15ea4e0.html#%E8%BD%ACboolean" target="_blank" rel="noopener noreferrer">#<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>转Boolean</strong></h3><p>在条件判断时，除了 <code>undefined</code>， <code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 <code>true</code>，包括所有对象。</p><h3 id="对象转原始类型" tabindex="-1"><a class="header-anchor" href="#对象转原始类型" aria-hidden="true">#</a> <strong><a href="https://doc.vercel.app/webyck/article/5bdc715f6fb9a049c15ea4e0.html#%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">#<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>对象转原始类型</strong></h3><p>对象在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑一般来说如下：</p><ul><li>如果已经是原始类型了，那就不需要转换了</li><li>如果需要转字符串类型就调用 <code>x.toString()</code>，转换为基础类型的话就返回转换的值。不是字符串类型的话就先调用 <code>valueOf</code>，结果不是基础类型的话再调用 <code>toString</code></li><li>调用 <code>x.valueOf()</code>，如果转换为基础类型，就返回转换的值</li><li>如果都没有返回原始类型，就会报错</li></ul><p>当然你也可以重写 <code>Symbol.toPrimitive</code> ，该方法在转原始类型时调用优先级最高。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = {
  valueOf() {
    return 0
  },
  toString() {
    return &#39;1&#39;
  },
  [Symbol.toPrimitive]() {
    return 2
  }
}
1 + a // =&gt; 3

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="四则运算符" tabindex="-1"><a class="header-anchor" href="#四则运算符" aria-hidden="true">#</a> <strong><a href="https://doc.vercel.app/webyck/article/5bdc715f6fb9a049c15ea4e0.html#%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E7%AC%A6" target="_blank" rel="noopener noreferrer">#<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>四则运算符</strong></h3><p>加法运算符不同于其他几个运算符，它有以下几个特点：</p><ul><li><p>运算中其中一方为字符串，那么就会把另一方也转换为字符串</p></li><li><p>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</p><p>1 + &#39;1&#39; // &#39;11&#39; true + true // 2 4 + [1,2,3] // &quot;41,2,3&quot;</p></li></ul><p>如果你对于答案有疑问的话，请看解析：</p><ul><li>对于第一行代码来说，触发特点一，所以将数字 <code>1</code> 转换为字符串，得到结果 <code>&#39;11&#39;</code></li><li>对于第二行代码来说，触发特点二，所以将 <code>true</code> 转为数字 <code>1</code></li><li>对于第三行代码来说，触发特点二，所以将数组通过 <code>toString</code> 转为字符串 <code>1,2,3</code>，得到结果 <code>41,2,3</code></li></ul><p>另外对于加法还需要注意这个表达式 <code>&#39;a&#39; + + &#39;b&#39;</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&#39;a&#39; + + &#39;b&#39; // -&gt; &quot;aNaN&quot;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 <code>+ &#39;b&#39;</code> 等于 <code>NaN</code>，所以结果为 <code>&quot;aNaN&quot;</code>，你可能也会在一些代码中看到过 <code>+ &#39;1&#39;</code> 的形式来快速获取 <code>number</code> 类型。</p><p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>4 * &#39;3&#39; // 12
4 * [] // 0
4 * [1, 2] // NaN

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="比较运算符" tabindex="-1"><a class="header-anchor" href="#比较运算符" aria-hidden="true">#</a> <strong><a href="https://doc.vercel.app/webyck/article/5bdc715f6fb9a049c15ea4e0.html#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6" target="_blank" rel="noopener noreferrer">#<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>比较运算符</strong></h3><ol><li><p>如果是对象，就通过 <code>toPrimitive</code> 转换对象</p></li><li><p>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</p><p>let a = { valueOf() { return 0 }, toString() { return &#39;1&#39; } } a &gt; -1 // true</p></li></ol><p>在以上代码中，因为 <code>a</code> 是对象，所以会通过 <code>valueOf</code> 转换为原始类型再比较值。</p><h2 id="this" tabindex="-1"><a class="header-anchor" href="#this" aria-hidden="true">#</a> <strong><a href="https://doc.vercel.app/webyck/article/5bdc715f6fb9a049c15ea4e0.html#this" target="_blank" rel="noopener noreferrer">#<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>this</strong></h2><blockquote><p>涉及面试题：如何正确判断 this？箭头函数的 this 是什么？</p></blockquote><p><code>this</code> 是很多人会混淆的概念，但是其实它一点都不难，只是网上很多文章把简单的东西说复杂了。在这一小节中，你一定会彻底明白 <code>this</code> 这个概念的。</p><p>我们先来看几个函数调用的场景</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们一个个分析上面几个场景</p><ul><li>对于直接调用 <code>foo</code> 来说，不管 <code>foo</code> 函数被放在了什么地方，<code>this</code> 一定是 <code>window</code></li><li>对于 <code>obj.foo()</code> 来说，我们只需要记住，谁调用了函数，谁就是 <code>this</code>，所以在这个场景下 <code>foo</code> 函数中的 <code>this</code> 就是 <code>obj</code> 对象</li><li>对于 <code>new</code> 的方式来说，<code>this</code> 被永远绑定在了 <code>c</code> 上面，不会被任何方式改变 <code>this</code></li></ul><p>说完了以上几种情况，其实很多代码中的 <code>this</code> 应该就没什么问题了，下面让我们看看箭头函数中的 <code>this</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function a() {
  return () =&gt; {
    return () =&gt; {
      console.log(this)
    }
  }
}
console.log(a()()())

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先箭头函数其实是没有 <code>this</code> 的，箭头函数中的 <code>this</code> 只取决包裹箭头函数的第一个普通函数的 <code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是 <code>a</code>，所以此时的 <code>this</code> 是 <code>window</code>。另外对箭头函数使用 <code>bind</code> 这类函数是无效的。</p><p>最后种情况也就是 <code>bind</code> 这些改变上下文的 API 了，对于这些函数来说，<code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。</p><p>那么说到 <code>bind</code>，不知道大家是否考虑过，如果对一个函数进行多次 <code>bind</code>，那么上下文会是什么呢？</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // =&gt; ?

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你认为输出结果是 <code>a</code>，那么你就错了，其实我们可以把上述代码转换成另一种形式</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>// fn.bind().bind(a) 等于
let fn2 = function fn1() {
  return function() {
    return fn.apply()
  }.apply(a)
}
fn2()

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以从上述代码中发现，不管我们给函数 <code>bind</code> 几次，<code>fn</code> 中的 <code>this</code> 永远由第一次 <code>bind</code> 决定，所以结果永远是 <code>window</code>。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>let a = { name: &#39;yck&#39; }
function foo() {
  console.log(this.name)
}
foo.bind(a)() // =&gt; &#39;yck&#39;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就是 <code>this</code> 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 <code>this</code> 最终指向哪里。</p><p>首先，<code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</p><p>如果你还是觉得有点绕，那么就看以下的这张流程图吧，图中的流程只针对于单个规则。</p><p><a href="https://user-gold-cdn.xitu.io/2018/11/15/16717eaf3383aae8?w=744&amp;h=531&amp;f=png&amp;s=32062" target="_blank" rel="noopener noreferrer">https://user-gold-cdn.xitu.io/2018/11/15/16717eaf3383aae8?w=744&amp;h=531&amp;f=png&amp;s=32062<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> <strong>小结</strong></h2><p>以上就是我们 JS 基础知识点的第一部分内容了。这一小节中涉及到的知识点在我们日常的开发中经常可以看到，并且很多容易出现的坑 也出自于这些知识点，相信认真读完的你一定会在日后的开发中少踩很多坑。如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。</p></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">最新更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: lzh@gmail.com">shanzha</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/pages/interview/a.html" class="" aria-label="JS 基础知识点及常考面试题（二）"><!--[--><!--]--> JS 基础知识点及常考面试题（二） <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.d9a40c70.js" defer></script>
  </body>
</html>
